import { Injectable } from '@angular/core';
import { Observable, BehaviorSubject } from 'rxjs';
import firebase from 'firebase/compat/app';
import { Timestamp } from '@angular/fire/firestore';

export interface TimelineEvent {
  documentID: string;
  author: string;
  title: string;
  location: string;
  description: string;
  startTime: Timestamp; 
  endTime: Timestamp;
}

@Injectable({
  providedIn: 'root'
})
export class TimelineService {
  private eventsSubject = new BehaviorSubject<TimelineEvent[] | null>(null);
  events$: Observable<TimelineEvent[]> = this.eventsSubject.asObservable();
  
  constructor() {
    firebase.firestore().collection('timeline')
      .orderBy('startTime', 'asc') // Order by startTime in ascending order
      .onSnapshot(snapshot => {
        const events = snapshot.docs.map(doc => ({
          documentID: doc.id,
          author: doc.data().author,
          title: doc.data().title,
          description: doc.data().description,
          location: doc.data().location,
          startTime: doc.data().startTime.toDate(), 
          endTime: doc.data().endTime.toDate()  
        } as TimelineEvent));
        this.eventsSubject.next(events);
      }, error => {
        console.error('Error fetching timeline events:', error);
      });
  }
  
  /**
   * Returns an observable stream of timeline events.
   */
  getEvents(): Observable<TimelineEvent[]> {
    return this.events$;
  }
  
  /**
   * Creates a new timeline event.
   * @param event Partial event data (excluding documentID, which is generated by Firestore)
   */
  addEvent(event: Partial<TimelineEvent>): Promise<firebase.firestore.DocumentReference> {
    // Convert startTime and endTime to Firestore Timestamps.
    const eventData = {
      author: event.author || '',
      title: event.title || '',
      location: event.location || '',
      description: event.description || '',
      startTime: firebase.firestore.Timestamp.fromDate(new Date(event.startTime as any)),
      endTime: firebase.firestore.Timestamp.fromDate(new Date(event.endTime as any))
    };
    return firebase.firestore().collection('timeline').add(eventData);
  }
  
  /**
   * Updates an existing timeline event.
   * @param documentID The document ID of the event to update.
   * @param event Partial event data to update.
   */
  updateEvent(documentID: string, event: Partial<TimelineEvent>): Promise<void> {
    const eventData = {
      author: event.author || '',
      title: event.title || '',
      location: event.location || '',
      description: event.description || '',
      startTime: firebase.firestore.Timestamp.fromDate(new Date(event.startTime as any)),
      endTime: firebase.firestore.Timestamp.fromDate(new Date(event.endTime as any))
    };
    return firebase.firestore().collection('timeline').doc(documentID).update(eventData);
  }
  
  /**
   * Deletes a timeline event.
   * @param documentID The document ID of the event to delete.
   */
  deleteEvent(documentID: string): Promise<void> {
    return firebase.firestore().collection('timeline').doc(documentID).delete();
  }
}
