import { Injectable } from '@angular/core';
import { Observable, BehaviorSubject } from 'rxjs';
import firebase from 'firebase/compat/app';
import { Timestamp } from '@angular/fire/firestore';

export interface TimelineEvent {
  documentID: string;
  createdBy: string;
  title: string;
  location: string;
  description: string;
  startTime: Timestamp; 
  endTime: Timestamp;
}

@Injectable({
  providedIn: 'root'
})
export class TimelineService {
  //private eventsSubject = new BehaviorSubject<TimelineEvent[] | null>(null);
  private eventsSubject = new BehaviorSubject<TimelineEvent[]>([]);
  events$: Observable<TimelineEvent[]> = this.eventsSubject.asObservable();
  
  constructor() {
    firebase.firestore().collection('timeline')
      .orderBy('startTime', 'asc')
      .onSnapshot(snapshot => {
  
        if (snapshot.empty) {
          console.warn('No events found in Firestore.');
          this.eventsSubject.next([]); // ðŸ”¥ Emit empty array instead of null
          return;
        }
  
        const events = snapshot.docs.map(doc => {
          const data = doc.data();
          return {
            documentID: doc.id,
            title: data.title || 'Untitled Event',
            description: data.description || 'No description provided.',
            location: data.location || 'Unknown location',
            startTime: data.startTime?.toDate ? data.startTime.toDate() : new Date(),
            endTime: data.endTime?.toDate ? data.endTime.toDate() : new Date()
          } as TimelineEvent;
        });
  
        this.eventsSubject.next(events);
      }, error => {
        this.eventsSubject.next([]); // ðŸ”¥ Emit empty array if there's an error
      });
  }
  
  
  /**
   * Returns an observable stream of timeline events.
   */
  getEvents(): Observable<TimelineEvent[]> {
    return this.events$;
  }
  
  /**
   * Creates a new timeline event.
   * @param event Partial event data (excluding documentID, which is generated by Firestore)
   */
  addEvent(event: Partial<TimelineEvent>): Promise<firebase.firestore.DocumentReference> {
    // Convert startTime and endTime to Firestore Timestamps.
    const eventData = {
      title: event.title || '',
      location: event.location || '',
      description: event.description || '',
      startTime: firebase.firestore.Timestamp.fromDate(new Date(event.startTime as any)),
      endTime: firebase.firestore.Timestamp.fromDate(new Date(event.endTime as any))
    };
    return firebase.firestore().collection('timeline').add(eventData);
  }
  
  /**
   * Updates an existing timeline event.
   * @param documentID The document ID of the event to update.
   * @param event Partial event data to update.
   */
  updateEvent(documentID: string, event: Partial<TimelineEvent>): Promise<void> {
    const eventData = {
      title: event.title || '',
      location: event.location || '',
      description: event.description || '',
      startTime: firebase.firestore.Timestamp.fromDate(new Date(event.startTime as any)),
      endTime: firebase.firestore.Timestamp.fromDate(new Date(event.endTime as any))
    };
    return firebase.firestore().collection('timeline').doc(documentID).update(eventData);
  }
  
  /**
   * Deletes a timeline event.
   * @param documentID The document ID of the event to delete.
   */
  deleteEvent(documentID: string): Promise<void> {
    return firebase.firestore().collection('timeline').doc(documentID).delete();
  }
}
